<template class='doc-view'>
    <header id='fixed-top'>
        高级
    </header>
    <h2 id='fixed-define'>
        自定义
    </h2>
    <p>
        在大部分情况，你都需要自定义一些扩展，自定义扩展需要遵循一定的规则。
    </p>
    <h3 id='fixed-component'>
        组件
    </h3>
    <pre q-code>
@Component({
    selector: string,
    template: string,
    styles: Array<string>
})
export default class {
    // todo
};
    </pre>
    <p>
        class里面可以定义启动方法和生命周期钩子等方法。
    </p>
    <h4 id='fixed-component-setup'>
        $setup
    </h4>
    <p>
        一个方法，应该返回一个json，用于定义双向绑定的数据和方法。
    </p>
    <pre q-code>
$setup(){
    return {
        doit(){
            // todo
        }
    };
}
    </pre>
    <p>
        我们可以看到，我们定义了一个方法doit，这样，你就可以通过this.doit在定义的别的方法或生命周期钩子中调用了。
    </p>
    <p>
        对于双向绑定的数据，你需要借助两个方法：
    </p>
    <pre q-code>
import { reactive, ref } from 'nefbl';
...
    @setup(){

        let info = ref('1');
        let infoObj = reactive({});

        return {
            info,
            infoObj
        };
    }
...
    </pre>
    <h4 id='fixed-component-mounted'>
        $mounted
    </h4>
    <p>
        组件挂载完成执行。
    </p>
    <h4 id='fixed-component-beforeUpdate'>
        $beforeUpdate
    </h4>
    <p>
        数据改变导致的更新执行前触发。
    </p>
    <h4 id='fixed-component-updated'>
        $updated
    </h4>
    <p>
        数据改变导致的更新执行后触发。
    </p>
    <h3 id='fixed-directive'>
        指令
    </h3>
    <pre q-code>
@Directive({
    selector: string
})
export default class {
    // todo
};
    </pre>
    <p>
        class里面可以定义生命周期钩子等方法。
    </p>
    <h4 id='fixed-directive-inserted'>
        $inserted
    </h4>
    <p>
        指令第一次生效的时候执行。
    </p>
    <h4 id='fixed-directive-update'>
        $update
    </h4>
    <p>
        数据改变导致的更新触发。
    </p>
    <p>
        所有的生命周期钩子，其实就是一个方法，语法如下：
    </p>
    <pre q-code>
function(el, binding){
    // todo
}
    </pre>
    <p>
        其中el表示指令所在的DOM结点，binding是一个json，记录着一些信息。
    </p>
    <p>
        指令使用的时候，基本格式如下：
    </p>
    <pre q-code='html'>
        <XXX ui-demo:type='exp'></XXX>
    </pre>
    <p>
        binding就记录了指令在使用的时候的详细信息：
    </p>
    <ul>
        <li>
            <span class="important">type</span>
            ：ui-demo是指令的名字，type是补充的额外信息。
        </li>
        <li>
            <span class="important">exp</span>
            ：指令本身就是属性，exp相当于属性值。
        </li>
        <li>
            <span class="important">value</span>
            ：属性值在当前组件对象上作为表达式解析后的值。
        </li>
    </ul>
    <h2 id='fixed-module'>
        模块
    </h2>
    <p>
        虽然一个模块也是可以的，不过如果项目规模越来越大的时候，多模块会是更好的选择。
    </p>
    <pre q-code>
@Module(options)
export default class {
    // todo
};
    </pre>
    <h3 id='fixed-module-options'>
        options
    </h3>
    <p>
        这是一个json，你可以通过这个配置项来配置模块，下面是所有可用的配置项。
    </p>
    <h4 id='fixed-module-options-bootstrap'>
        bootstrap
    </h4>
    <p>
        值应该是一个组件，表示当前模块的启动组件，只有主模块需要配置。
    </p>
    <h4 id='fixed-module-options-declarations'>
        declarations
    </h4>
    <p>
        值应该是一个数组，用于声明本模块具有的组件、指令。
    </p>
    <h4 id='fixed-module-options-imports'>
        imports
    </h4>
    <p>
        值应该是一个数组，在这里引入别的模块，引入就意味着，本模块具有引入模块的组件、指令（需要在exports中登记）。
    </p>
    <h4 id='fixed-module-options-exports'>
        exports
    </h4>
    <p>
        值应该是一个数组，暴露的内容，如果别的模块想用本模块的内容，需要本模块这此处暴露。
    </p>
</template>
